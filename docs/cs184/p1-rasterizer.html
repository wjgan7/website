<!-- Contains meta things e.g. fonts, CSS, Google Analytics, SEO -->

<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title></title>

    <!-- The Roboto font used by all pages. -->
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- For code highlighting -->
    <link rel="stylesheet" href="/assets/css/github.css">

    <!-- MathJax -->
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-131264326-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-131264326-1');
    </script>

<!-- Begin Jekyll SEO tag v2.5.0 -->
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="https://wjgan.com/cs184/p1-rasterizer.html" />
<meta property="og:url" content="https://wjgan.com/cs184/p1-rasterizer.html" />
<script type="application/ld+json">
{"url":"https://wjgan.com/cs184/p1-rasterizer.html","@type":"WebPage","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>
  <body>
    <h3> <a href="/index.html">Home</a> </h3>
<h1 id="cs-184-computer-graphics-and-imaging-spring-2019">CS 184: Computer Graphics and Imaging, Spring 2019</h1>

<h1 id="project-1-rasterizer">Project 1: Rasterizer</h1>

<h2 id="william-gan-cs184-ado">William Gan, cs184-ado</h2>

<h2 id="overview">Overview</h2>

<p>For this project <a href="https://cs184.eecs.berkeley.edu/sp19/article/6/assignment-1-rasterizer">(link)</a>, I implemented a triangle rasterizer that supports</p>

<ul>
  <li>Different supersampling rates.</li>
  <li>Texture mapping.
    <ul>
      <li>Nearest and bilinear pixel sampling of textures.</li>
      <li>Zero, nearest, and bilinear mipmap level sampling for antialiasing.</li>
    </ul>
  </li>
</ul>

<p>While this doc skims over the well-known details, it focuses on some tricky things I encountered along the way, as well as pictures and summaries of the results. Before coming into this project, I only knew rasterization as a word. However, now I think I have a good understanding of how rasterization works and implementation details / performance tradeoffs.</p>

<h2 id="section-i-rasterization">Section I: Rasterization</h2>

<h3 id="part-1-rasterizing-single-color-triangles">Part 1: Rasterizing single-color triangles</h3>

<ul>
  <li>For every pixel <script type="math/tex">(r,c)</script> in the bounding box of the triangle <strong>and</strong> within the limits of the <em>samplebuffer</em>, I determined if <script type="math/tex">(r+0.5, c+0.5)</script> was in the triangle, and colored the pixel if it was.</li>
  <li>To determine if the point is in the triangle, I used the method described in lecture. Here were some tricky things I ran into.
    <ol>
      <li>
        <p><strong>Making sure the normal vectors point inside</strong>. First, I got normal vectors for each side</p>

        <script type="math/tex; mode=display">n_1 = (y_0 - y_1, x_1 - x_0)</script>

        <script type="math/tex; mode=display">n_2 = (y_1 - y_2, x_2 - x_1)</script>

        <script type="math/tex; mode=display">v_3 = (y_2 - y_0, x_0 - x_2)</script>

        <p>By construction, the normal vectors either all pointed inside or outside. To determine which, I leveraged the fact that <script type="math/tex">n_1</script> should have pointed in the direction of <script type="math/tex">p_2</script>. Namely the dot product of <script type="math/tex">n_1</script> and the vector from <script type="math/tex">p_0</script> to <script type="math/tex">p_2</script> should have been positive. Here’s a code snippet.</p>

        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">n1</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y0</span><span class="p">),</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">);</span>
 <span class="n">n2</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">),</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">);</span>
 <span class="n">n3</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">y0</span> <span class="o">-</span> <span class="n">y2</span><span class="p">),</span> <span class="n">x0</span> <span class="o">-</span> <span class="n">x2</span><span class="p">);</span>

 <span class="k">if</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">Vector2D</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">n1</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
   <span class="n">n2</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
   <span class="n">n3</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p><strong>OpenGL Edge Rules.</strong> Another tricky thing was to check if a normal vector corresponded to a vector that was a top edge or a left edge. For top edges, I checked to make sure that the normal vector was pointing strictly down. For a left edge, I checked to make sure the dot product of the normal vector with <script type="math/tex">(1, 0)</script> was positive.</p>

        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">bool</span> <span class="n">is_top1</span> <span class="o">=</span> <span class="n">n1</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n1</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
 <span class="kt">bool</span> <span class="n">is_top2</span> <span class="o">=</span> <span class="n">n2</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n2</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
 <span class="kt">bool</span> <span class="n">is_top3</span> <span class="o">=</span> <span class="n">n3</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n3</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>

 <span class="kt">bool</span> <span class="n">is_left1</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">Vector2D</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
 <span class="kt">bool</span> <span class="n">is_left2</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">Vector2D</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
 <span class="kt">bool</span> <span class="n">is_left3</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">n3</span><span class="p">,</span> <span class="n">Vector2D</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
</ul>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="/assets/cs184/p1-rasterizer/part1.png" align="middle" width="480" />
        <figcaption align="middle">Here is my basic/test4.svg</figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 id="part-2-antialiasing-triangles">Part 2: Antialiasing triangles</h3>

<ul>
  <li>
    <p>In part 1, I sampled at <script type="math/tex">(r+0.5, c+0.5)</script>. For this part, I divided the pixel into subpixels and sampled at the center of each. The formula for the centers of the ith subpixel vertically and the jth subpixel horizontally is</p>

    <script type="math/tex; mode=display">(r + \frac{2 \cdot i+1}{2 \cdot \text{samples_per_side}}, c + \frac{2 \cdot j+1}{2 \cdot \text{samples_per_side}})</script>

    <p>where <script type="math/tex">i, j \in 0, 1, \dots, \text{samples_per_side}-1</script>.</p>
  </li>
  <li>
    <p>At the end, I averaged every subpixel to find overall color. This way, a pixel wouldn’t be just white or the color but also in between.</p>
  </li>
</ul>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="/assets/cs184/p1-rasterizer/part1.png" align="middle" width="400px" />
        <figcaption align="middle">Sample rate 1, same picture as above</figcaption>
      </td>
      <td>
        <img src="/assets/cs184/p1-rasterizer/part2_4.png" align="middle" width="400px" />
        <figcaption align="middle">Sample rate 4.</figcaption>
      </td>
      <td>
        <img src="/assets/cs184/p1-rasterizer/part2_16.png" align="middle" width="400px" />
        <figcaption align="middle">Sample rate 16.</figcaption>
      </td>
    </tr>
  </table>
</div>

<p>The pixels near the edges took intermediate values / were blurred because within a pixel, the area inside the triangle and the area outside was averaged. The blur increased with the sample rate since that led to a closer approximation of what the size those areas were.</p>

<h3 id="part-3-transforms">Part 3: Transforms</h3>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="/assets/cs184/p1-rasterizer/part3_robot.png" align="middle" width="400px" />
      </td>
      <td>
        <img src="/assets/cs184/p1-rasterizer/part3.png" align="middle" width="400px" />
      </td>
    </tr>
  </table>
</div>

<p>For my cubeman, I changed the body blocks to black and the face to white. For the eyes, I took the torso code and translated / scaled it. For the moustache, I translated and drew a triangle. I later figured out the right scale of triangle. Because I knew the coordinates from the torso, I drew the white shirt manually. For the bowtie, however, I translated and rescaled similar to how I did the moustache.</p>

<h2 id="section-ii-sampling">Section II: Sampling</h2>

<h3 id="part-4-barycentric-coordinates">Part 4: Barycentric coordinates</h3>

<p>The idea behind barycentric coordinates is that we can express points inside the triangle in terms of the triangle’s vertices. In particular, if a triangle’s vertices are <script type="math/tex">A = (x_A, y_A)</script>, <script type="math/tex">B = (x_B, y_B)</script>, <script type="math/tex">C = (x_C, y_C)</script>, we can write</p>

<script type="math/tex; mode=display">(x,y) = \alpha A + \beta B + \gamma C</script>

<p>where <script type="math/tex">0 \leq \alpha, \beta, \gamma \leq 1</script>. Furthermore, we can do so in a way such that</p>

<script type="math/tex; mode=display">\alpha + \beta + \gamma = 1</script>

<p>The advantage of this representation is that since the coordinates are from 0 to 1 and add up to 1, they tell us relatively how “similiar” each point in the triangle is to each of the 3 vertices.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="/assets/cs184/p1-rasterizer/part4_vertices.png" align="middle" width="400px" />
      </td>
      <td>
        <img src="/assets/cs184/p1-rasterizer/part4_fill.png" align="middle" width="400px" />
      </td>
    </tr>
  </table>
</div>

<p>The two pictures above show how you can fill in a triangle with vertices colored red, green, and blue. For each point inside the triangle, we use its barycentric coordinate to determine what percent it is red, green, and blue.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="/assets/cs184/p1-rasterizer/part4_wheel.png" align="middle" width="400px" />
        <figcaption align="middle">Color wheel generation.</figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 id="part-5-pixel-sampling-for-texture-mapping">Part 5: “Pixel sampling” for texture mapping</h3>

<ul>
  <li>In Part 4, if a screen (sub)pixel was in a triangle, I would convert it to barycentric coordinates and then send it to a ColorTri. ColorTri would use the coordinate values to return a weighted average of the ColorTri’s 3 vertex colors.</li>
  <li>In this part, I sent the barycentric coordinates to a TexTri. Instead of just being 3 vertices with 3 colors, a TexTri is actually a triangle-shaped image stored in a different file.</li>
  <li>
    <p>Using the barycentric coordinates, I figured out the corresponding texture pixel (texel). To recap, a screen pixel <script type="math/tex">(x,y)</script> inside a triangle can be expressed as</p>

    <script type="math/tex; mode=display">(x,y) = \alpha A + \beta B + \gamma C</script>

    <p>where <script type="math/tex">0 \leq \alpha, \beta, \gamma \leq 1</script> and <script type="math/tex">\alpha + \beta + \gamma = 1</script>. The vertices of the triangle in the texture file (<script type="math/tex">E</script>, <script type="math/tex">F</script>, <script type="math/tex">G</script>) can be used to find the texel <script type="math/tex">(u,v)</script>.</p>

    <script type="math/tex; mode=display">(u,v) = \alpha E + \beta F + \gamma G</script>

    <p>However, the issue is that the texture file is still made up of a pixels, meaning <script type="math/tex">(u,v)</script> is supposed to be made up of whole numbers. There are two ways to fix this.</p>
    <ul>
      <li><em>Nearest</em>: Truncate (Floor) <script type="math/tex">(u,v)</script> so that they become whole numbers and take the color value there.</li>
      <li>
        <p><em>Bilinear</em>: <script type="math/tex">(u,v)</script> is bounded by the square with the following corners.</p>

        <script type="math/tex; mode=display">\{ (\lfloor u \rfloor, \lfloor v \rfloor), (\lfloor u \rfloor, \lceil v \rceil), (\lceil u \rceil, \lfloor v \rfloor), (\lceil u \rceil, \lceil v \rceil) \}</script>

        <p>Similar to how in ColorTri we use barycentric coordinates to average the RGB of the triangle’s 3 vertices, something similar can be done here to average the RGB of the 4 corners.</p>
      </li>
    </ul>
  </li>
</ul>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="/assets/cs184/p1-rasterizer/part5_nearest_1.png" align="middle" width="400px" />
        <figcaption align="middle">Nearest pixel sampling. Supersampling rate: 1.</figcaption>
      </td>
      <td>
        <img src="/assets/cs184/p1-rasterizer/part5_bilinear_1.png" align="middle" width="400px" />
        <figcaption align="middle">Bilinear pixel sampling. Supersampling rate: 1.</figcaption>
      </td>
    </tr>
    <tr>
      <td>
        <img src="/assets/cs184/p1-rasterizer/part5_nearest_16.png" align="middle" width="400px" />
        <figcaption align="middle">Nearest pixel sampling. Supersampling rate: 16.</figcaption>
      </td>
      <td>
        <img src="/assets/cs184/p1-rasterizer/part5_bilinear_16.png" align="middle" width="400px" />
        <figcaption align="middle">Bilinear pixel sampling. Supersampling rate: 16.</figcaption>
      </td>
    </tr>
  </table>
</div>

<p>For rendering the globe image, the latitude and longitude lines were hard to get right. With nearest pixel sampling, they appeared faded out / disconnected at times. However, with bilinear sampling, they appeared smooth and connected. In fact, bilinear pixel sampling at supersampling rate 1 was better than nearest pixel sampling at rate 16.</p>

<h3 id="part-6-level-sampling-with-mipmaps-for-texture-mapping">Part 6: “Level sampling” with mipmaps for texture mapping</h3>

<p>When rendering, we sample to determine a pixel value. One seemingly unimportant detail is that we sample at the same rate for every pixel. But a single pixel can map to a region of arbitrary area in the texture file. Furthermore these areas will be different. So we might need to sample in the texture file at different rates.</p>

<p>We could adjust our super sampling rate, but there is an efficiency tradeoff. There are also other techniques we can do to fix this. One, which is level sampling, is to store the texture file at different resolutions. If the original texture file was 128 x 128 texels, I could also make it 64x64 by averaging every 2x2 block into 1 texel. If a screen pixel maps to a large area in the texture file, I should sample from the smaller texture files, because that texture file inherently averages texels value for us, which supersampling would do. We want to store many levels (128 x 128, 64 x 64, 32 x 32, etc.) and figure out the best level to sample from when rendering.</p>

<p>Here’s how I calculated the Mipmap level</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">Texture</span><span class="o">::</span><span class="n">get_level</span><span class="p">(</span><span class="k">const</span> <span class="n">SampleParams</span> <span class="o">&amp;</span><span class="n">sp</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Optional helper function for Parts 5 and 6
</span>
  <span class="kt">double</span> <span class="n">du_dx</span> <span class="o">=</span> <span class="n">sp</span><span class="p">.</span><span class="n">p_dx_uv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">width</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">dv_dx</span> <span class="o">=</span> <span class="n">sp</span><span class="p">.</span><span class="n">p_dx_uv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">du_dy</span> <span class="o">=</span> <span class="n">sp</span><span class="p">.</span><span class="n">p_dy_uv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">width</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">dv_dy</span> <span class="o">=</span> <span class="n">sp</span><span class="p">.</span><span class="n">p_dy_uv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>

  <span class="kt">double</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">du_dx</span><span class="o">*</span><span class="n">du_dx</span> <span class="o">+</span> <span class="n">dv_dx</span><span class="o">*</span><span class="n">dv_dx</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">du_dy</span><span class="o">*</span><span class="n">du_dy</span> <span class="o">+</span> <span class="n">dv_dy</span><span class="o">*</span><span class="n">dv_dy</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">l</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">log2</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here’s a table of the average FPS for each technique.</p>

<table>
  <tbody>
    <tr>
      <td> </td>
      <td>Nearest Sampling</td>
      <td>Bilinear Sampling</td>
    </tr>
    <tr>
      <td>Zero Level</td>
      <td>100 FPS</td>
      <td>90 FPS</td>
    </tr>
    <tr>
      <td>Nearest Level</td>
      <td>90 FPS</td>
      <td>80 FPS</td>
    </tr>
    <tr>
      <td>Bilinear Level</td>
      <td>80 FPS</td>
      <td>70 FPS</td>
    </tr>
  </tbody>
</table>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="/assets/cs184/p1-rasterizer/part6_zero_nearest.png" align="middle" width="400px" />
        <figcaption align="middle">Zero level. Nearest pixel sampling.</figcaption>
      </td>
      <td>
        <img src="/assets/cs184/p1-rasterizer/part6_zero_bilinear.png" align="middle" width="400px" />
        <figcaption align="middle">Zero level. Bilinear pixel sampling.</figcaption>
      </td>
    </tr>
    <tr>
      <td>
        <img src="/assets/cs184/p1-rasterizer/part6_nearest_nearest.png" align="middle" width="400px" />
        <figcaption align="middle">Nearest level. Nearest pixel sampling</figcaption>
      </td>
      <td>
        <img src="/assets/cs184/p1-rasterizer/part6_nearest_bilinear.png" align="middle" width="400px" />
        <figcaption align="middle">Nearest level. Bilinear pixel sampling.</figcaption>
      </td>
    </tr>
  </table>
</div>

<p>Not that easy to tell at this level of zoom, but the zero level, nearest pixel sampling had the highest level of sharpness, followed by zero level, bilinear pixel sampling and then the nearest level techniques. At the same time, sharpness also came with jaggies / moire (although since this picture is a mountain it sort of blends in). Overall, I learned that unless the zoom is very far out, zero level, nearest pixel was still the best for images like this.</p>

  </body>
</html>
