<!-- Contains meta things e.g. fonts, CSS, Google Analytics, SEO -->

<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Computation</title>

    <!-- The Roboto font used by all pages. -->
    <link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,700" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- For code highlighting -->
    <link rel="stylesheet" href="/assets/css/code.css">

    <!-- MathJax -->
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-131264326-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-131264326-1');
    </script>

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Computation</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Computation" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="https://wjgan.com/posts/computing.html" />
<meta property="og:url" content="https://wjgan.com/posts/computing.html" />
<script type="application/ld+json">
{"url":"https://wjgan.com/posts/computing.html","headline":"Computation","@type":"WebPage","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>

<div class="body-center">
  <div class="container">
    <div class="content">
      <h3> <a href="/index.html">Home</a> </h3>
      <h1 id="computing-probabilities-and-expectations">Computing Probabilities and Expectations</h1>

<p>Coding is pretty underrated when it comes to a subject like probability. EECS 126 is so focused on math that the importance of, e.g. being able to simulate a random process, is often lost.</p>

<h2 id="motivation">Motivation</h2>

<h3 id="fall-2015-mt1-1e">Fall 2015 MT1 1(e)</h3>

<p>Code is illuminating because it can verify answers. For example, here’s the question and solution for <a href="/assets/computing/fa15_sol.pdf">1(e) on Midterm 1 of Fall 2015</a>.</p>

<div align="middle">
  <img src="/assets/computing/q1e.png" align="middle" width="680px" height="321px" />
</div>

<p>The answer is intuitive – it invokes “symmetry” – but if we run this code segment which simulates the random process</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">trials</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">500000</span><span class="p">):</span>
    <span class="n">rolls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">max_roll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">max</span><span class="p">(</span><span class="n">rolls</span><span class="p">)</span>
    <span class="n">trials</span><span class="p">[</span><span class="n">max_roll</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rolls</span><span class="p">))</span>

<span class="n">Y</span> <span class="o">=</span> <span class="mi">99</span>
<span class="n">expected</span> <span class="o">=</span> <span class="mf">0.51</span><span class="o">*</span><span class="n">Y</span>
<span class="n">actual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">trials</span><span class="p">[</span><span class="n">Y</span><span class="p">])</span>
<span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">trials</span><span class="p">[</span><span class="n">Y</span><span class="p">])</span><span class="o">/</span><span class="n">samples</span><span class="o">**</span><span class="mf">0.5</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'Y={Y} samples={samples}</span><span class="se">\n</span><span class="s">'</span> <span class="o">+</span>
      <span class="n">f</span><span class="s">'expected:{expected : .3f} actual {actual : .6f}</span><span class="se">\n</span><span class="s">'</span><span class="o">+</span>
      <span class="n">f</span><span class="s">'std: {std :.6f} error: {abs(expected-actual)/std: 0.6f} standard deviations</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div>

<div>
  <img src="/assets/computing/output.png" width="649px" height="77px" />
</div>

<p>our expected answer based on the formula <script type="math/tex">\frac{51}{100}Y</script> and the actual empirical <script type="math/tex">E[Z \mid Y]</script> don’t match up. Even though they only differ by a slight amount (50.49 vs 50.27), that’s 24 standard deviations given the fact we had 197,588 samples. And since the CLT tells us that our empirical <script type="math/tex">E[Z \mid Y]</script> will be normally distributed around its true value, 24 standard deviations away basically happens with 0 probability.</p>

<p>The issue ends up being very subtle, but it relates to the fact that <script type="math/tex">\sum_{i \not = j} E[X_i \mid Y]</script> doesn’t make sense since <script type="math/tex">j</script> is random. It’s not pretty, but the correct answer ends up being</p>

<script type="math/tex; mode=display">E[Z \mid Y] = \frac{\frac{Y(Y-1)}{2} ((Y+1)^{49} - Y^{49}) + Y(Y+1)^{49}}{(Y+1)^{50} - Y^{50}}</script>

<p>A derivation of that is in this <a href="/assets/computing/fa15mt1q1e.ipynb">Jupyter Notebook</a>, which also has the full code.</p>

<h3 id="shuffled-deck-problem">Shuffled Deck Problem</h3>

<p>Code can also guide us to answers. Consider this problem:</p>

<blockquote>
  <p>You have a randomly shuffled deck of cards labeled 1 to N. You keep drawing cards from the top of the deck while the numbers increase. What is expected sum of this increasing run?</p>
</blockquote>

<p>The answer to this question is elegant, but it turns out finding it mostly involves algebraic bashing. In fact, it’s really hard to derive the answer without knowing it in the first place. This is where code comes in.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="n">tup</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tup</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tup</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">tup</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">s</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">permutation</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">score</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'N: {N} Expectation: {s / math.factorial(N)}'</span><span class="p">)</span>
</code></pre></div></div>

<div>
  <img src="/assets/computing/shuffled_deck_output.png" width="469px" height="177px" />
</div>

<p>The answer gets increasingly close to <script type="math/tex">N+1</script> as <script type="math/tex">N</script> gets larger. We can see that it is off by <script type="math/tex">\frac{1}{2}</script> for <script type="math/tex">N=2</script> and <script type="math/tex">\frac{1}{6}</script> for <script type="math/tex">N=3</script>. It turns out it’s <script type="math/tex">\frac{1}{24}</script> for <script type="math/tex">N=4</script>, and which leads us to realize that it’s off by <script type="math/tex">\frac{1}{N!}</script>. The answer ends up being</p>

<script type="math/tex; mode=display">N+1 - \frac{1}{N!}</script>

<p>How you derive that is still hard, but knowing the answer helps, especially as you can use Wolfram Alpha to see if intermediate formulas are equal to the answer.</p>

<details>
<br />
<summary>
Here's how you can derive the answer. Credits to Forest Yang.
</summary>

If we let $$S$$ be the sum of the run and $$X_k = \begin{cases} \text{the label of the $k$-th card} &amp; \text{if it is in the run} \\ 0 &amp; \text{otherwise} \end{cases}$$. Then

$$
\begin{align*}
  E[S] &amp; = \sum_{k=1}^N E[X_i] \\
  &amp; = \sum_{k=1}^N P(\text{$X_k$ is bigger than $X_{k-1}, \dots, X_{1}$}) \cdot E[X_k \mid \text{$X_k$ is bigger than $X_{k-1}, \dots, X_{1}$}] \\
  &amp; = \sum_{k=1}^N \frac{1}{k!} E[X_k \mid \text{$X_k$ is the max of the first $k$}] \\
  &amp; = \sum_{k=1}^N \frac{1}{k!} \cdot \Bigl[ k + \frac{k}{k+1} \cdot (N-k) \Bigr] \\
  &amp; = \sum_{k=1}^N \frac{1}{k!} \cdot \frac{k^2 + k + Nk - k^2}{k+1} \\
  &amp; = \sum_{k=1}^N \frac{Nk + k}{(k+1)!} \\
  &amp; = (N+1) \sum_{k=1}^N \frac{k}{(k+1)!} \\
  &amp; = (N+1) \sum_{k=1}^N \Bigl[ \frac{1}{k!} - \frac{1}{(k+1)!} \Bigr] \\
  &amp; = (N+1) \Bigl[ \Bigl( \frac{1}{1!} - \frac{1}{2!} \Bigr) + \dots + \Bigl( \frac{1}{N!} - \frac{1}{(N+1)!} \Bigr) \Bigr] \\
  &amp; = (N+1) \cdot \Bigl( 1 - \frac{1}{(N+1)!} \Bigr) \\
  &amp; = N + 1 - \frac{1}{N!}
\end{align*}
$$

</details>
<p><br /></p>

<h2 id="overview">Overview</h2>

<p>When it comes to computing probabilities and expectations, it’s ususally either Monte Carlo or brute force / dynamic programming.</p>

<h3 id="monte-carlo-method">Monte Carlo method</h3>

<p>Monte Carlo kind of just means randomly simulating a process and averaging results to calculate a value. For example, one of the classic ways to approximate <script type="math/tex">\pi</script> is to randomly throw darts at square and see what proportion of them lie in a quarter-circle. If we let <script type="math/tex">Z_i</script> be an indicator random variable for a whether dart is in the quarter-circle, we know that</p>

<script type="math/tex; mode=display">P(Z_i = 1) = \frac{\text{Area of quarter-circle}}{\text{Area of square}} = \frac{\frac{1}{4} \cdot \pi \cdot 1^2}{1 \cdot 1} = \frac{\pi}{4}</script>

<p>And since we know that the proportion of darts in the circle, <script type="math/tex">\frac{1}{N} \sum\limits_{i=1}^N Z_i</script>, converges to its expectation, <script type="math/tex">\frac{\pi}{4}</script>, by the LLN / CLT, that means if we have enough samples we can approximate <script type="math/tex">\pi</script> as 4 times that proportion.</p>

<div align="middle">
  <img src="/assets/computing/monte_carlo.gif" width="500px" height="500px" />
</div>

<h4 id="nprandomrand">np.random.rand()</h4>

<p>When it comes to Monte Carlo, the tools you’ll be using mostly involve the <code class="highlighter-rouge">np.random</code> module. The most important of which is <code class="highlighter-rouge">np.random.rand</code> (or <code class="highlighter-rouge">np.random.random_sample</code>, <code class="highlighter-rouge">np.random.random</code>, etc., they all do the same thing).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">dn</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">np.random.rand(10)</code> creates a length 10 array of random floats between <script type="math/tex">[0, 1)</script>. <code class="highlighter-rouge">np.random.rand(3, 3)</code> does that but for a <script type="math/tex">3 \times 3</script> matrix. <code class="highlighter-rouge">np.random.rand()</code> just returns one random float.</p>

<p>Here’s the approximation to <script type="math/tex">\pi</script> using this function.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">SAMPLES</span> <span class="o">=</span> <span class="mi">100000</span>

<span class="c"># x and y coordinate for each sample</span>
<span class="n">points_on_square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">SAMPLES</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c"># d^2 = x^2 + y^2</span>
<span class="n">distance_squared</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">points_on_square</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c"># 1 if d^2 &lt;= 1, 0 otherwise</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">distance_squared</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">proportion</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'Pi: {4 * proportion}'</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">np.random.rand</code> is also important because you can basically sample from any continuous distribution with it so long as you know the inverse of the CDF, <script type="math/tex">F^{-1}(x)</script>. For example for an exponential random variable <script type="math/tex">F(x) = 1 - e^{-\lambda x}</script>, so if we wanted to generate a random <script type="math/tex">x</script> we could let <script type="math/tex">u</script> be a random number from <script type="math/tex">[0, 1)</script> and then set <script type="math/tex">1 - e^{- \lambda x} = u</script>, or <script type="math/tex">x = - \frac{\ln (1 - u)}{\lambda}</script>. It turns out that if we follow this procedure, the <script type="math/tex">x</script>’s we generate will be distributed exponentially.</p>

<p>Here are some exercises you might want to try.</p>

<ul>
  <li>Uniformly randomly generate a point in a circle of radius <script type="math/tex">r</script>.</li>
  <li>Uniformly randomly generate a point on a sphere of radius <script type="math/tex">r</script>.</li>
  <li>Uniformly randomly generate a point in the region between two circles of radii <script type="math/tex">r_1</script> and <script type="math/tex">r_2</script>.</li>
</ul>

<h4 id="other-things-about-nprandom">Other Things About np.random</h4>

<p>Another important method is <code class="highlighter-rouge">np.random.randint</code>. <code class="highlighter-rouge">np.random.randint(6) + 1</code> randomly generates a dice roll from 1 to 6. <code class="highlighter-rouge">np.random.randint(2000, 2020)</code> randomly generates a year from 2000 to 2019, but does not include 2020. You can do <code class="highlighter-rouge">np.random.randint(1, 7, size=100)</code> to randomly generate 100 dice rolls.</p>

<p>Here’s a <a href="https://docs.scipy.org/doc/numpy/reference/routines.random.html">full list</a> of the functions in the <code class="highlighter-rouge">np.random</code> module. It includes functions for sampling from common distributions directly, e.g. exponential.</p>

<h4 id="drawbacks-of-monte-carlo">Drawbacks of Monte Carlo</h4>

<p>We do Monte Carlo in the Fall 2015 MT1 1(e) code: we essentially simulate 50 rolls and then look at the average. But our code is not that efficient because we’re looking for a conditional expectation, i.e. we only care about the average roll given the max roll. That’s why even though we generate 500,000 samples, only 197,588 are used for when we’re looking at <script type="math/tex">E[Z \mid Y = 99]</script>. For smaller max rolls, the issue becomes more severe. For example the probability of the max roll being at most 49 is <script type="math/tex">(\frac{50}{100})^{-50} = 2^{-50}</script>, so we’ll basically never get even get one sample for cases where <script type="math/tex">Y \leq 49</script>.</p>

<p>Even when we are able to use all of our samples though, Monte Carlo still isn’t great. For example the code above that uses 100,000 samples to approximate <script type="math/tex">\pi</script> returns 3.14984, which isn’t even accurate to the 3rd digit.</p>

<p><em>Note: sometimes you can be smarter about Monte Carlo in that you don’t waste many samples, but that’s not the case here</em>.</p>

<h3 id="brute-force--dynamic-programming">Brute Force / Dynamic Programming</h3>

<p>This is where the second technique come in. Sometimes it’s possible to enumerate (i.e. brute force) over all outcomes and calculate the expectation exactly. For example, in the Shuffled Deck Problem, in order to figure out the expected length of the first run, we enumerated over all <script type="math/tex">N!</script> ways that the deck could have been shuffled and calculated the run length for each one. Since each permutation of the deck was equally likely, we simply averaged all these run lengths in the end to produce the expectation.</p>

<h4 id="itertools">itertools</h4>

<p>For these combinatorial brute forces, the tools you typically want to use are in Python’s <code class="highlighter-rouge">itertools</code> library. The documentation is <a href="https://docs.python.org/3/library/itertools.html">linked here</a>, but the important functions are:</p>

<ul>
  <li><code class="highlighter-rouge">itertools.product</code>. This returns a generator for Cartesian products.
    <ul>
      <li><code class="highlighter-rouge">itertools.product(['H', 'T'], repeat=4)</code> will return all possible outcomes from 4 coin flips.</li>
      <li><code class="highlighter-rouge">itertools.product(['H', 'T'], range(1, 7))</code> will return all possible outcomes of a coin flip then a dice roll.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">itertools.permutations</code>. This returns a generator for permutations.
    <ul>
      <li><code class="highlighter-rouge">itertools.permutations(range(1, N+1))</code> will return all permutations of integers 1 to <script type="math/tex">N</script>, which we used in the Shuffled Deck Problem.</li>
      <li><code class="highlighter-rouge">itertools.permutations(['Argentina', 'Belgium', 'Brazil', 'England', 'France', 'Germany', 'Portugal', 'Spain'], r=3)</code> will return every 3-permutation out of these 8 options, maybe representing the Top 3 at the World Cup.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">itertools.combinations</code>. This returns a generator for combinations, and it basically acts the same way as permutations.</li>
</ul>

<h4 id="drawbacks-of-brute-force">Drawbacks of Brute Force</h4>

<p>The issue with brute force is of course, you’re brute forcing. It isn’t feasible for Fall 2015 MT1 1(e) because there are <script type="math/tex">100^{50}</script> ways roll a 100-sided die 50 times. Even for the shuffled deck problem, it isn’t really be feasible for <script type="math/tex">N</script> greater than 10. When this issue occurs, we sometimes need to fall back on Monte Carlo. But actually sometimes we don’t need to because there’s a recurrence going on. And in those cases we can take advantage of dynamic programming.</p>

<h4 id="dynamic-programming">Dynamic Programming</h4>

<p>We can’t brute force Fall 2015 MT1 1(e) because there are <script type="math/tex">100^{50}</script> outcomes. But let’s look at the problem. It’s hard because we’re saying the max is <script type="math/tex">Y</script>. This means that every roll is at most <script type="math/tex">Y</script> <strong>and</strong> there is at least one roll equal to <script type="math/tex">Y</script>. If it were just that every roll is at most <script type="math/tex">Y</script>, the expected average would just be <script type="math/tex">\frac{Y}{2}</script>. However, it turns out there is a recurrence relation that makes the max case simple as well.</p>

<p>Say we let <script type="math/tex">f(n)</script> be the expected <strong>sum</strong> of <script type="math/tex">n</script> rolls given that the max of these <script type="math/tex">n</script> rolls is <script type="math/tex">Y</script>. <script type="math/tex">E[Z \mid Y]</script> is the expected <strong>average</strong> with <script type="math/tex">n = 50</script>, so our “answer” is <script type="math/tex">\frac{1}{50} f(50)</script>. <script type="math/tex">f(n)</script> is nice because if we let <script type="math/tex">p(n)</script> be the probability that the <script type="math/tex">n</script>-th roll is a <script type="math/tex">Y</script>, then</p>

<script type="math/tex; mode=display">f(n) = p(n) \cdot (Y + (n-1) \cdot \frac{Y}{2}) + (1 - p(n)) \cdot (\frac{Y-1}{2} + f(n-1))</script>

<p>The reasoning behind this formula is as follows. If the <script type="math/tex">n</script>-th roll is a <script type="math/tex">Y</script>, then we don’t need to worry about there being at least one roll equal to <script type="math/tex">Y</script> for the remaining <script type="math/tex">n-1</script> rolls, and the expected sum is  the <script type="math/tex">Y</script> we rolled plus the expected sum of <script type="math/tex">n-1</script> rolls that are at most <script type="math/tex">Y</script>, which is <script type="math/tex">(n-1) \cdot \frac{Y}{2}</script>. On the other hand, if the <script type="math/tex">n</script>-th roll is not a <script type="math/tex">Y</script>, then its expectation is <script type="math/tex">\frac{Y-1}{2}</script>, and the expected sum of the remaining rolls is <script type="math/tex">f(n-1)</script>.</p>

<p>So what’s <script type="math/tex">p(n)</script>? The answer is</p>

<script type="math/tex; mode=display">p(n) = \frac{(Y+1)^{n-1}}{(Y+1)^n - Y^n}</script>

<p>There are <script type="math/tex">(Y+1)^n</script> ways roll a die <script type="math/tex">n</script> times such that every roll is at most <script type="math/tex">Y</script>. Of those, there are <script type="math/tex">Y^n</script> ways roll a die <script type="math/tex">n</script> times such that every role is at most <script type="math/tex">Y-1</script>, in which case there won’t be at least one roll equal to <script type="math/tex">Y</script>. So the number of ways to roll the die such that the max is <script type="math/tex">Y</script> is <script type="math/tex">(Y+1)^n - Y^n</script>. Of those, there are <script type="math/tex">(Y+1)^{n-1}</script> ways to roll such that the <script type="math/tex">n</script>-flip is a <script type="math/tex">Y</script>, since if it is, then the other <script type="math/tex">n-1</script> rolls just need to be at most <script type="math/tex">Y</script>.</p>

<p>Here’s the code calculating <script type="math/tex">E[Z \mid Y = 99]</script> using the recurrence relation above.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">Y</span> <span class="o">=</span> <span class="mi">99</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">51</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">Y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">Y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">n</span> <span class="o">-</span> <span class="n">Y</span><span class="o">**</span><span class="n">n</span><span class="p">)</span>
    <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">Y</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Y</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">Y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'E[Z | Y={Y}]: {f[50]/50}'</span><span class="p">)</span>
</code></pre></div></div>

<div>
  <img src="/assets/computing/dp_output.png" width="293px" height="34px" />
</div>

<p>This code is a lot more efficient than the Monte Carlo version, computes the <strong>exact</strong> answer, and also works for different values of <script type="math/tex">Y</script>.</p>

<p>Dynamic programming is pretty hard: it’s not easy to see the “state”, the recurrence, or figure out <script type="math/tex">p(n)</script>. But the takeaway is that it can enable us to compute probabilities and expectations in an efficient matter. Furthermore, you get a lot better at figuring these states and recurrences with practice and the common ways to recurse.</p>

<!-- Here are some exercises you might want to try. -->

<h2 id="conclusion">Conclusion</h2>

<p>Code can be useful for verifying and finding answers. Actually, there are some problems that don’t have closed-form solutions but can still be approximated with Monte Carlo simulation or computed exactly with brute force / dynamic programming. In general these two techniques represent contrasting ways to compute probabilites and expectations. Monte Carlo simulation is easy to implement but is often inefficient and will only give you rough answers. Brute force / dynamic programming will give you exact answers, and dynamic programming in particular is efficient. However, this comes at the cost of being hard to implement and bug prone, and not all problems can be solved in such a manner. Getting good at both can improve your understanding of probability and is also pretty useful practically.</p>

    </div>
    <script src="/assets/js/clipbutton.js"></script>
  </div>
</div>
  </body>
</html>
